<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.0.6" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.6">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.6">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.6">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.6" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.0.6',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="CGD 的简述GCD 全称 Grand Central Dispatch。简单来说就是 Apple 对于优化应用程序以及支持多核处理器所开发的多核编程的最新解决方案。本文主要对于开发中常用的进行简述，不会针对底层解析，想研究底层请看这里。 本文示例均采用 Swift 4 实现。Swift 3 以前在开发中使用 GCD 不是太友好 — 由于它的编程风格接近 C，与 Swift style 差别很大，">
<meta property="og:type" content="article">
<meta property="og:title" content="常用的 GCD">
<meta property="og:url" content="http://yoursite.com/2018/05/01/关于 GCD/index.html">
<meta property="og:site_name" content="Inception">
<meta property="og:description" content="CGD 的简述GCD 全称 Grand Central Dispatch。简单来说就是 Apple 对于优化应用程序以及支持多核处理器所开发的多核编程的最新解决方案。本文主要对于开发中常用的进行简述，不会针对底层解析，想研究底层请看这里。 本文示例均采用 Swift 4 实现。Swift 3 以前在开发中使用 GCD 不是太友好 — 由于它的编程风格接近 C，与 Swift style 差别很大，">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-09-09T15:20:54.470Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="常用的 GCD">
<meta name="twitter:description" content="CGD 的简述GCD 全称 Grand Central Dispatch。简单来说就是 Apple 对于优化应用程序以及支持多核处理器所开发的多核编程的最新解决方案。本文主要对于开发中常用的进行简述，不会针对底层解析，想研究底层请看这里。 本文示例均采用 Swift 4 实现。Swift 3 以前在开发中使用 GCD 不是太友好 — 由于它的编程风格接近 C，与 Swift style 差别很大，">






  <link rel="canonical" href="http://yoursite.com/2018/05/01/关于 GCD/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>常用的 GCD | Inception</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> 

<div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Inception</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Stay Hungry Stay Foolish</p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        
          
  <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Home</a>
</li>

      
        
        
          
  <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />Archives</a>
</li>

      

      
    </ul>
  

  
    

  

  
</nav>


  



 </div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/01/关于 GCD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MorningStar">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Inception">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">常用的 GCD</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-01T13:20:14+08:00">2018-05-01</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="CGD-的简述"><a href="#CGD-的简述" class="headerlink" title="CGD 的简述"></a>CGD 的简述</h2><p>GCD 全称 <a href="https://en.wikipedia.org/wiki/Grand_Central_Dispatch" target="_blank" rel="noopener">Grand Central Dispatch</a>。<br>简单来说就是 Apple 对于优化应用程序以及支持多核处理器所开发的多核编程的最新解决方案。本文主要对于开发中常用的进行简述，不会针对底层解析，想研究底层请看<a href="https://apple.github.io/swift-corelibs-libdispatch/" target="_blank" rel="noopener">这里</a>。</p>
<p>本文示例均采用 Swift 4 实现。Swift 3 以前在开发中使用 GCD 不是太友好 — 由于它的编程风格接近 C，与 Swift style 差别很大，API 难记难用，即使在 Objective-C 中使用也不太方便。这也是很多开发者都使用 NSOperationQueue 而避免 GCD 的主要原因。</p>
<p>Swift 3 中 Apple 采用了全新的 Swift style 重写了 GCD，这使 GCD 在开发中的使用与之前完全截然不同，轻松上手，好记好用。否则，也不会有这篇文章了。<br><a id="more"></a></p>
<h2 id="GCD-的核心"><a href="#GCD-的核心" class="headerlink" title="GCD 的核心"></a>GCD 的核心</h2><h3 id="任务及其执行方式"><a href="#任务及其执行方式" class="headerlink" title="任务及其执行方式"></a>任务及其执行方式</h3><p>任务就是线程中要执行的代码，它可以随同队列的创建一起被创建，然后将这个任务添加指定的执行方式（<strong><em>同步执行</em></strong> 和<strong><em>异步执行</em></strong>）。</p>
<p>想象使用音乐播放器放歌，正在播放的歌就是<strong><font color="#D13720">执行的任务</font></strong>，音乐播放器是先创建了播放列表然后将你选的这首歌添加到播放列表（这就类似于上述的<strong><font color="#D13720">任务随着队列的创建一起创建</font></strong>），最后开始播放，也就是执行任务。</p>
<p>那<strong><em>同步执行</em></strong> 和<strong><em>异步执行</em></strong> 呢？<br>你先添加歌曲 1 到播放列表，然后添加歌曲 2 到播放列表。歌曲 1 正在播放时，同一音乐播放器的播放列表中的歌曲 2 是无法播放的，（假设此时无法打开另一个播放器，这就相当于不具备开启新线程能力）只能手动切换或是等待歌曲 1 播放完成后才可以播放歌曲 2，也就是必须歌曲 1 结束，歌曲 2 才能进行。<br>这就是<strong><em>同步执行</em></strong>。</p>
<p>歌曲 1 正在播放时，你打开了另一个播放器（开启新线程），播放歌曲 2，无需等待歌曲 1（任务）结束），这时两个播放器一起播放歌曲，同时播放歌曲 1 和歌曲 2。<br>这就是<strong><em>异步执行</em></strong>。</p>
<p>综上所述，二者之间的区别：</p>
<p><strong>同步执行：</strong></p>
<ul>
<li>必须一个任务执行结束才能执行下一个，换句话说，任务 1 执行时，任务 2 会一直等待到任务 1 执行完毕才会继续执行。</li>
<li>不具备开启新线程能力。</li>
</ul>
<p><strong>异步执行：</strong></p>
<ul>
<li>下一个任务无需任何等待，即使当前任务正在执行，也可以继续执行下一人任务。</li>
<li>具备开启新线程能力。</li>
</ul>
<blockquote>
<p><strong>By the way</strong><br>异步执行虽然具备开启新线程的能力，但是，是否可以开启新线程与队列类型有关。</p>
</blockquote>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>Dispatch Queue。还是刚才的例子，先到添加到播放列表的先放，后添加的后放（FIFO）。<strong><font color="#D13720">队列</font></strong>就是指类似于播放列表这种<strong><font color="#D13720">执行任务的队列</font></strong>，列表中要播放的音乐就是要执行的<strong><font color="#D13720">任务</font></strong>。</p>
<p>队列是一种特殊的线性表，采用 FIFO（先进先出）的原则，队列上的任务也是遵循 FIFO 模式的，类似于栈（stack）那样。一旦创建完成系统直接接管，GCD 自己有线程管理池，无论多少队列，它们都会自动被系统正确管理。换句话说，我们只需要搞好任务、执行方式、队列，无需和线程直接打交道。</p>
<p>再来想象一下音乐播放器放歌，你只需要找到你想要播放的歌曲，然后添加到播放列表，你无须管理播放器什么时候切换下一曲。</p>
<p>一个队列是可以<strong>串行</strong>或者<strong>并行</strong>的。<br>串行队列就像一个播放器播放，并行队列就像多个播放器同时播放。</p>
<p>在<strong>串行队列（Serial Dispatch Queue）</strong>中，一个任务只有在前一个任务完成后才能执行（除非它是第一个任务），并且只能在一个线程中执行任务；<br>而在<strong>并行队列（Concurrent Dispatch Queue）</strong>中，所有的任务都可以同时（并发）执行。</p>
<blockquote>
<p><strong>By the way</strong></p>
<ul>
<li>FIFO = First In First Out</li>
<li>并行队列的并发功能只有在异步（async）函数下有效。</li>
<li>为主队列添加任务时，必须谨慎。因为主队列实时交互用户层面，所有关于 UI 的更新必须在主线程执行，如果在其他线程尝试更新常常会有意想不到的错误。</li>
<li>对于开发者来说，除了在主线程更新 UI 的任务，在哪条线程执行其他任务是未知的。</li>
</ul>
</blockquote>
<h3 id="队列以及执行方式的组合使用"><a href="#队列以及执行方式的组合使用" class="headerlink" title="队列以及执行方式的组合使用"></a>队列以及执行方式的组合使用</h3><h4 id="Dispatch-Queue"><a href="#Dispatch-Queue" class="headerlink" title="Dispatch Queue"></a>Dispatch Queue</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> queue = <span class="type">DispatchQueue</span>(label: <span class="string">"com.MorningStar.queue"</span>)</span><br></pre></td></tr></table></figure>
<p>这是创建 Dispatch Queue 的最简便方法，该方法有个参数<code>label</code>，该参数用于为队列创建一个标识符。</p>
<p>诺，现在有了队列，就来执行吧。</p>
<blockquote>
<p><strong>Note</strong></p>
<ul>
<li>简便方法创建的是串行队列。</li>
<li>不同的水果代表不同的队列，以便在 console 上清楚的识别打印内容。</li>
</ul>
</blockquote>
<h4 id="串行队列（Serial-Dispatch-Queue）"><a href="#串行队列（Serial-Dispatch-Queue）" class="headerlink" title="串行队列（Serial Dispatch Queue）"></a>串行队列（Serial Dispatch Queue）</h4><h5 id="串行队列同步执行"><a href="#串行队列同步执行" class="headerlink" title="串行队列同步执行"></a>串行队列同步执行</h5><p>先<code>sync</code>同步执行</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">queue.sync &#123;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..&lt;<span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"🍎"</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queue.sync &#123;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">5</span>..&lt;<span class="number">10</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"🍎"</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Prints</span>：</span><br><span class="line">🍎 <span class="number">1</span></span><br><span class="line">🍎 <span class="number">2</span></span><br><span class="line">🍎 <span class="number">3</span></span><br><span class="line">🍎 <span class="number">4</span></span><br><span class="line">🍎 <span class="number">5</span></span><br><span class="line">🍎 <span class="number">6</span></span><br><span class="line">🍎 <span class="number">7</span></span><br><span class="line">🍎 <span class="number">8</span></span><br><span class="line">🍎 <span class="number">9</span></span><br></pre></td></tr></table></figure>
<p>代码与打印结果清晰的反应了，自定义队列在主线程上按顺序执行。</p>
<blockquote>
<p><strong>串行同步</strong><br>任务会在一条线程上顺序依次执行，并且不具备开启子线程能力。</p>
</blockquote>
<h5 id="串行队列异步执行"><a href="#串行队列异步执行" class="headerlink" title="串行队列异步执行"></a>串行队列异步执行</h5><p>接下来使用异步<code>async</code>会发生什么？<br>代码写成这样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> queue1 = <span class="type">DispatchQueue</span>(label: <span class="string">"com.MorningStar.queue1"</span>)</span><br><span class="line"><span class="keyword">let</span> queue2 = <span class="type">DispatchQueue</span>(label: <span class="string">"com.MorningStar.queue2"</span>)</span><br><span class="line"></span><br><span class="line">queue1.async &#123;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..&lt;<span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"🍎"</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queue1.async &#123;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">5</span>..&lt;<span class="number">10</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"🍎"</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queue2.async &#123;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">10</span>..&lt;<span class="number">15</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"🍐"</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Prints</span>：</span><br><span class="line">🍎 <span class="number">1</span></span><br><span class="line">🍎 <span class="number">2</span></span><br><span class="line">🍎 <span class="number">3</span></span><br><span class="line">🍎 <span class="number">4</span></span><br><span class="line">🍐 <span class="number">10</span></span><br><span class="line">🍐 <span class="number">11</span></span><br><span class="line">🍐 <span class="number">12</span></span><br><span class="line">🍐 <span class="number">13</span></span><br><span class="line">🍐 <span class="number">14</span></span><br><span class="line">🍎 <span class="number">5</span></span><br><span class="line">🍎 <span class="number">6</span></span><br><span class="line">🍎 <span class="number">7</span></span><br><span class="line">🍎 <span class="number">8</span></span><br><span class="line">🍎 <span class="number">9</span></span><br></pre></td></tr></table></figure>
<p>这次的打印结果似乎有点意思，如果你多执行几次或许会发现每次输出的结果可能都不一样。无论 queue 2 中的任务何时执行（打印），这两个队列中任务的执行（打印）顺序是不变的, 🍎 的打印结果永远是 1-9 的顺序排列，🍐永远是 10-14，这也就证明了之前提到的观点：</p>
<blockquote>
<p><strong>串行异步</strong></p>
<ul>
<li>同一串行队列的任务即使是异步执行也只在同一线程上按顺序依次执行。</li>
<li>不同串行队列异步执行，有几条串行队列异步执行，就会有几条线程。也就是说串行队列只会开启一条新线程或者不开启新线程，在当前线执行。但是同一串行队列上的任务（不论何种执行方式）只会在负责该队列的一条线程顺序执行。</li>
<li>队列执行完毕顺序只和（接下来说到的）Qos（优先级）有关。</li>
</ul>
</blockquote>
<p>如果有兴趣，可在代码中多添加几条串行队列，并在异步执行任务的输出时打印线程试试结果。</p>
<h4 id="DispatchQoS"><a href="#DispatchQoS" class="headerlink" title="DispatchQoS"></a>DispatchQoS</h4><p>有些时候我们使用 GCD 执行任务时需要对任务有个先后排序，哪些先执行，哪些后执行，也就是任务的优先级。</p>
<p>回想一下，或许你会想起之前简便创建 <code>DispatchQueue</code> 时 Xcode 提示了一个构造方法：<br><code>DispatchQueue(label:qos:attributes:autoreleaseFrequency:target:)</code><br>该方法的第二个构造参数名就是 qos（Quality Of Service），其参数类型是<code>DispatchQoS</code>。会用于指定任务重要程度以及优先级的信息。<br>Xcode 的开发者文档对于 <code>DispatchQoS</code>有如下解释：</p>
<blockquote>
<p>Higher priority work is performed more quickly and with more resources than lower priority work, it typically requires more energy than lower priority work. Accurately specifying appropriate QoS classes for the work your app performs ensures that your app is responsive and energy efficient.</p>
</blockquote>
<p>翻翻代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">DispatchQoS</span> : <span class="title">Equatable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">let</span> qosClass: <span class="type">DispatchQoS</span>.<span class="type">QoSClass</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">QoSClass</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> unspecified</span><br><span class="line"></span><br><span class="line">        <span class="meta">@available</span>(<span class="type">OSX</span> <span class="number">10.10</span>, iOS <span class="number">8.0</span>, *)</span><br><span class="line">        <span class="keyword">case</span> background</span><br><span class="line"></span><br><span class="line">        <span class="meta">@available</span>(<span class="type">OSX</span> <span class="number">10.10</span>, iOS <span class="number">8.0</span>, *)</span><br><span class="line">        <span class="keyword">case</span> utility</span><br><span class="line"></span><br><span class="line">        <span class="meta">@available</span>(<span class="type">OSX</span> <span class="number">10.10</span>, iOS <span class="number">8.0</span>, *)</span><br><span class="line">        <span class="keyword">case</span> `<span class="keyword">default</span>`</span><br><span class="line"></span><br><span class="line">        <span class="meta">@available</span>(<span class="type">OSX</span> <span class="number">10.10</span>, iOS <span class="number">8.0</span>, *)</span><br><span class="line">        <span class="keyword">case</span> userInitiated</span><br><span class="line"></span><br><span class="line">        <span class="meta">@available</span>(<span class="type">OSX</span> <span class="number">10.10</span>, iOS <span class="number">8.0</span>, *)</span><br><span class="line">        <span class="keyword">case</span> userInteractive</span><br></pre></td></tr></table></figure>
<p>我们可以根据需求使用合适的 QoS 值来初始化队列。如果没有指定 QoS，则队列会使用默认优先级进行初始化。上面的枚举 <code>QoSClass</code> 的 case 是从低到高优先级的排序。</p>
<p>现在把代码改成这样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> queue1 = <span class="type">DispatchQueue</span>(label: <span class="string">"com.MorningStar.queue1"</span>, qos: .userInitiated)</span><br><span class="line"><span class="keyword">let</span> queue2 = <span class="type">DispatchQueue</span>(label: <span class="string">"com.MorningStar.queue2"</span>, qos: .utility)</span><br><span class="line"></span><br><span class="line">queue1.async &#123;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..&lt;<span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"🍎"</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queue2.async &#123;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">10</span>..&lt;<span class="number">15</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"🍐"</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queue1.async &#123;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">5</span>..&lt;<span class="number">10</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"🍎"</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Prints</span>：</span><br><span class="line">🍎 <span class="number">1</span>  🍐 <span class="number">10</span></span><br><span class="line">🍎 <span class="number">2</span>  🍎 <span class="number">1</span></span><br><span class="line">🍎 <span class="number">3</span>  🍎 <span class="number">2</span></span><br><span class="line">🍎 <span class="number">4</span>  🍎 <span class="number">3</span></span><br><span class="line">🍎 <span class="number">5</span>  🍎 <span class="number">4</span></span><br><span class="line">🍎 <span class="number">6</span>  🍎 <span class="number">5</span></span><br><span class="line">🍎 <span class="number">7</span>  🍎 <span class="number">6</span></span><br><span class="line">🍎 <span class="number">8</span>  🍎 <span class="number">7</span></span><br><span class="line">🍎 <span class="number">9</span>  🍎 <span class="number">8</span></span><br><span class="line">🍐 <span class="number">10</span> 🍎 <span class="number">9</span></span><br><span class="line">🍐 <span class="number">11</span> 🍐 <span class="number">11</span></span><br><span class="line">🍐 <span class="number">12</span> 🍐 <span class="number">12</span></span><br><span class="line">🍐 <span class="number">13</span> 🍐 <span class="number">13</span></span><br><span class="line">🍐 <span class="number">14</span> 🍐 <span class="number">14</span></span><br></pre></td></tr></table></figure>
<p>上面代码每次执行的结果可能不同，我只提取了两种结果，但是可以清晰的看出 queue 1 比 queue 2 执行任务要快，因为 queue 1 优先级高，即使 queue 2 获得了执行的机会，但是系统还是会先把资源优先供给 queue 1，queue 1 结束后才会关注 queue 2。</p>
<blockquote>
<p>Note</p>
<ul>
<li>主线程执行的任务永远是最高优先级。</li>
<li>优先级代表执行完成的速度。</li>
<li>当然如果创建时并不指定优先级参数(Qos)，也不会有任何问题，它会被设为默认级别。</li>
</ul>
</blockquote>
<h4 id="并行队列（Concurrent-Dispatch-Queue）"><a href="#并行队列（Concurrent-Dispatch-Queue）" class="headerlink" title="并行队列（Concurrent Dispatch Queue）"></a>并行队列（Concurrent Dispatch Queue）</h4><p>如果我们向串行队列加入 N 个任务，就像在一个音乐播放器的播放列表中添加了 N 首歌曲，它会按照顺序依次播放。</p>
<p>但如果你想让多个任务同时执行，那么，<strong>并行队列</strong>，了解一下？！</p>
<h5 id="并行队列异步执行"><a href="#并行队列异步执行" class="headerlink" title="并行队列异步执行"></a>并行队列异步执行</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> concurrentQueue = <span class="type">DispatchQueue</span>(label: <span class="string">"concurrent"</span>, qos: .utility, attributes: .concurrent)</span><br><span class="line"></span><br><span class="line">concurrentQueue.async &#123;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..&lt;<span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"🍎"</span>, i, <span class="type">Thread</span>.current)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">concurrentQueue.async &#123;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">5</span>..&lt;<span class="number">10</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"🍊"</span>, i, <span class="type">Thread</span>.current)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">concurrentQueue.async &#123;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">10</span>..&lt;<span class="number">15</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"🍐"</span>, i, <span class="type">Thread</span>.current)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Prints</span>:</span><br><span class="line">🍎 <span class="number">1</span> &lt;<span class="type">NSThread</span>: <span class="number">0x600001fe69c0</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line">🍎 <span class="number">2</span> &lt;<span class="type">NSThread</span>: <span class="number">0x600001fe69c0</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line">🍐 <span class="number">10</span> &lt;<span class="type">NSThread</span>: <span class="number">0x600001fc4b80</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br><span class="line">🍊 <span class="number">5</span> &lt;<span class="type">NSThread</span>: <span class="number">0x600001fcef00</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line">🍊 <span class="number">6</span> &lt;<span class="type">NSThread</span>: <span class="number">0x600001fcef00</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line">🍊 <span class="number">7</span> &lt;<span class="type">NSThread</span>: <span class="number">0x600001fcef00</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line">🍊 <span class="number">8</span> &lt;<span class="type">NSThread</span>: <span class="number">0x600001fcef00</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line">🍊 <span class="number">9</span> &lt;<span class="type">NSThread</span>: <span class="number">0x600001fcef00</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line">🍎 <span class="number">3</span> &lt;<span class="type">NSThread</span>: <span class="number">0x600001fe69c0</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line">🍎 <span class="number">4</span> &lt;<span class="type">NSThread</span>: <span class="number">0x600001fe69c0</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line">🍐 <span class="number">11</span> &lt;<span class="type">NSThread</span>: <span class="number">0x600001fc4b80</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br><span class="line">🍐 <span class="number">12</span> &lt;<span class="type">NSThread</span>: <span class="number">0x600001fc4b80</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br><span class="line">🍐 <span class="number">13</span> &lt;<span class="type">NSThread</span>: <span class="number">0x600001fc4b80</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br><span class="line">🍐 <span class="number">14</span> &lt;<span class="type">NSThread</span>: <span class="number">0x600001fc4b80</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<p>看哦，创建 <code>DispatchQueue</code> 的构造方法多个一个构造参数 <code>attributes</code>，该参数被指定为 <code>concurrent</code>，也就是<code>concurrentQueue</code>被设置为并行队列，该队列上的所有任务会被同时执行，否则就是串行队列。</p>
<p>打印结果清晰的显示每种水果所在的线程都是不同的，这说明<code>concurrentQueue</code>队列实际在三个线程上执行了任务。</p>
<blockquote>
<p><strong>并行异步</strong></p>
<ul>
<li>除了当前线程（主线程），系统又开启了3个线程，并且任务是交替/同时执行的。异步执行具备开启新线程的能力且并发队列可以开启多个线程，同时执行多个任务。</li>
<li>并行队列的并发功能只有在异步（async）函数下有效。</li>
</ul>
</blockquote>
<h5 id="并行队列同步执行"><a href="#并行队列同步执行" class="headerlink" title="并行队列同步执行"></a>并行队列同步执行</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> concurrentQueue = <span class="type">DispatchQueue</span>(label: <span class="string">"concurrent"</span>, attributes: .concurrent)</span><br><span class="line"></span><br><span class="line">concurrentQueue.sync &#123;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..&lt;<span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"🍎"</span>, i, <span class="type">Thread</span>.current)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">concurrentQueue.sync &#123;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">5</span>..&lt;<span class="number">10</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"🍊"</span>, i, <span class="type">Thread</span>.current)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">concurrentQueue.sync &#123;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">10</span>..&lt;<span class="number">15</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"🍐"</span>, i, <span class="type">Thread</span>.current)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Prints</span>:</span><br><span class="line">🍎 <span class="number">1</span> &lt;<span class="type">NSThread</span>: <span class="number">0x60000046bd80</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line">🍎 <span class="number">2</span> &lt;<span class="type">NSThread</span>: <span class="number">0x60000046bd80</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line">🍎 <span class="number">3</span> &lt;<span class="type">NSThread</span>: <span class="number">0x60000046bd80</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line">🍎 <span class="number">4</span> &lt;<span class="type">NSThread</span>: <span class="number">0x60000046bd80</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line">🍊 <span class="number">5</span> &lt;<span class="type">NSThread</span>: <span class="number">0x60000046bd80</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line">🍊 <span class="number">6</span> &lt;<span class="type">NSThread</span>: <span class="number">0x60000046bd80</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line">🍊 <span class="number">7</span> &lt;<span class="type">NSThread</span>: <span class="number">0x60000046bd80</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line">🍊 <span class="number">8</span> &lt;<span class="type">NSThread</span>: <span class="number">0x60000046bd80</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line">🍊 <span class="number">9</span> &lt;<span class="type">NSThread</span>: <span class="number">0x60000046bd80</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line">🍐 <span class="number">10</span> &lt;<span class="type">NSThread</span>: <span class="number">0x60000046bd80</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line">🍐 <span class="number">11</span> &lt;<span class="type">NSThread</span>: <span class="number">0x60000046bd80</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line">🍐 <span class="number">12</span> &lt;<span class="type">NSThread</span>: <span class="number">0x60000046bd80</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line">🍐 <span class="number">13</span> &lt;<span class="type">NSThread</span>: <span class="number">0x60000046bd80</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line">🍐 <span class="number">14</span> &lt;<span class="type">NSThread</span>: <span class="number">0x60000046bd80</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>并行同步</strong></p>
<ul>
<li>所有任务在同一线程（主线程）执行，因为同步执行没有开启新线程的能力。</li>
<li>所有任务都是按顺序依次执行的。虽然并发队列可以开启多个线程，同时执行多个任务。但是因为本身不能创建新线程，所以也就不存在并发。而当前线程只有等待当前队列中正在执行的任务执行完毕后，才能继续接着执行（同步任务需要等待队列的任务执行结束）。所以任务只能一个一个按顺序执行，不能同时被执行。这也就是为什么并发队列的并发功能只会在异步执行时才会生效。</li>
</ul>
</blockquote>
<h4 id="系统提供的现有队列"><a href="#系统提供的现有队列" class="headerlink" title="系统提供的现有队列"></a>系统提供的现有队列</h4><p>到这里，我相信串行并行同步异步的概念就应该完全清晰了。<br>上述都属于自定义队列，但实际开发中我们很少需要手动创建，那就来说说开发中常用的现有队列。<br>GCD 中的队列有如下几种：</p>
<ul>
<li>主线程队列（<code>DispatchQueue.main</code>）</li>
<li>全局并发队列（<code>DispatchQueue.global()</code>）</li>
<li>自定义队列</li>
<li>队列组（<code>DispatchGroup</code>）</li>
</ul>
<p>全局并发队列完全可以当做自定义的并发队列来使用，但是主队列有点特殊－了解一下？！</p>
<h5 id="主队列"><a href="#主队列" class="headerlink" title="主队列"></a>主队列</h5><h6 id="主队列同步执行与死锁"><a href="#主队列同步执行与死锁" class="headerlink" title="主队列同步执行与死锁"></a>主队列同步执行与死锁</h6><p>创建一个 Single View App，我们把下面这段代码放到 ViewController 中的 viewDidLoad 方法中。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DispatchQueue</span>.main.sync &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="type">Thread</span>.current)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行一下，哦！crash 了！Xcode 报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread 1: EXC_BAD_INSTRUCTION</span><br></pre></td></tr></table></figure>
<p>因为你把同步任务放到了主队列，现在主线程阻塞在这，等待同步任务执行完毕后继续执行，而<code>print(Thread.current)</code>这个同步任务又会等待主队列执行完<code>print(Thread.current)</code>这个同步任务，这样就会互相等待一直僵持，所以，Boom～这就是我们说的『<em>死锁</em>』。</p>
<blockquote>
<p>Note<br>队列添加任务，特别是嵌套任务一定要谨慎，串行队列执行任务时一旦再次碰上同步任务就会产生死锁。</p>
</blockquote>
<h6 id="主队列异步执行"><a href="#主队列异步执行" class="headerlink" title="主队列异步执行"></a>主队列异步执行</h6><p>既然同步不行那么我们来看看异步</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..&lt;<span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"🍎"</span>, i, <span class="type">Thread</span>.current)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">5</span>..&lt;<span class="number">10</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"🍊"</span>, i, <span class="type">Thread</span>.current)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Prints</span>:</span><br><span class="line">🍎 <span class="number">1</span> &lt;<span class="type">NSThread</span>: <span class="number">0x600000b819c0</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line">🍎 <span class="number">2</span> &lt;<span class="type">NSThread</span>: <span class="number">0x600000b819c0</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line">🍎 <span class="number">3</span> &lt;<span class="type">NSThread</span>: <span class="number">0x600000b819c0</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line">🍎 <span class="number">4</span> &lt;<span class="type">NSThread</span>: <span class="number">0x600000b819c0</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line">🍊 <span class="number">5</span> &lt;<span class="type">NSThread</span>: <span class="number">0x600000b819c0</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line">🍊 <span class="number">6</span> &lt;<span class="type">NSThread</span>: <span class="number">0x600000b819c0</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line">🍊 <span class="number">7</span> &lt;<span class="type">NSThread</span>: <span class="number">0x600000b819c0</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line">🍊 <span class="number">8</span> &lt;<span class="type">NSThread</span>: <span class="number">0x600000b819c0</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line">🍊 <span class="number">9</span> &lt;<span class="type">NSThread</span>: <span class="number">0x600000b819c0</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br></pre></td></tr></table></figure>
<p>whoop，没问题了，这就是串行队列异步执行任务，顺序依次执行每个任务。</p>
<h5 id="DispatchGroup"><a href="#DispatchGroup" class="headerlink" title="DispatchGroup"></a>DispatchGroup</h5><p>有时在开发中我们需要等待两个异步任务执行完毕都获取到结果后，再执行任务（例如两个网络请求，请求回来的结果拼接到一起再进行请求）。为此，DispatchGroup，了解一下？！</p>
<h6 id="DispatchGroup-notify"><a href="#DispatchGroup-notify" class="headerlink" title="DispatchGroup( ).notify"></a>DispatchGroup( ).notify</h6><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> group = <span class="type">DispatchGroup</span>()</span><br><span class="line"><span class="type">DispatchQueue</span>.global().async(group: group) &#123;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..&lt;<span class="number">5</span> &#123;</span><br><span class="line">        <span class="type">Thread</span>.sleep(forTimeInterval: <span class="number">2</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"🍎"</span>, i, <span class="type">Thread</span>.current)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">DispatchQueue</span>.global().async(group: group) &#123;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">5</span>..&lt;<span class="number">10</span> &#123;</span><br><span class="line">        <span class="type">Thread</span>.sleep(forTimeInterval: <span class="number">2</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"🍊"</span>, i, <span class="type">Thread</span>.current)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">group.notify(queue: <span class="type">DispatchQueue</span>.main) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"finished"</span>, <span class="type">Thread</span>.current)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>notify</code>这个方法会监听 group 的完成状态，当所有任务执行完成后再执行<code>notify</code>中的任务。<code>notify</code>有一个名为 queue 的参数，用于指定<code>notify</code>函数中任务执行的队列。</p>
<h6 id="DispatchGroup-wait"><a href="#DispatchGroup-wait" class="headerlink" title="DispatchGroup( ).wait"></a>DispatchGroup( ).wait</h6><p>把下面这段代码加到后面</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> wait = group.wait(timeout: .now() + <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> wait &#123;</span><br><span class="line"><span class="keyword">case</span> .success:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"success"</span>)</span><br><span class="line"><span class="keyword">case</span> .timedOut:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"timeout"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"finished"</span>, <span class="type">Thread</span>.current)</span><br><span class="line"><span class="type">Prints</span>:</span><br><span class="line">🍎 <span class="number">1</span> &lt;<span class="type">NSThread</span>: <span class="number">0x600001835180</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line">🍊 <span class="number">5</span> &lt;<span class="type">NSThread</span>: <span class="number">0x600001835200</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line">🍎 <span class="number">2</span> &lt;<span class="type">NSThread</span>: <span class="number">0x600001835180</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line">🍊 <span class="number">6</span> &lt;<span class="type">NSThread</span>: <span class="number">0x600001835200</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line">🍎 <span class="number">3</span> &lt;<span class="type">NSThread</span>: <span class="number">0x600001835180</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line">🍊 <span class="number">7</span> &lt;<span class="type">NSThread</span>: <span class="number">0x600001835200</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line">🍎 <span class="number">4</span> &lt;<span class="type">NSThread</span>: <span class="number">0x600001835180</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line">🍊 <span class="number">8</span> &lt;<span class="type">NSThread</span>: <span class="number">0x600001835200</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line">timeout</span><br><span class="line">finished &lt;<span class="type">NSThread</span>: <span class="number">0x600001852900</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line">🍊 <span class="number">9</span> &lt;<span class="type">NSThread</span>: <span class="number">0x600001835200</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<p><code>wait</code>方法接收一个类型为<code>DispatchTime</code>的参数<code>timeout</code>，由于wait方法会阻塞当前线程，等待 group 的任务全部执行完毕后再执行，<code>timeout</code>就用于指定阻塞时间，如果限定时间内没有完成就会返回一个类型为<code>DispatchTimeoutResult</code>枚举的 case，上述例子中的结果打印了 timeout 这是由于 10 秒不足以执行完模拟延迟的异步任务。</p>
<h6 id="DispatchGroup-enter、DispatchGroup-leave"><a href="#DispatchGroup-enter、DispatchGroup-leave" class="headerlink" title="DispatchGroup().enter、DispatchGroup().leave"></a>DispatchGroup().enter、DispatchGroup().leave</h6><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> group = <span class="type">DispatchGroup</span>()</span><br><span class="line">group.enter()</span><br><span class="line"><span class="type">DispatchQueue</span>.global().async() &#123;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..&lt;<span class="number">5</span> &#123;</span><br><span class="line">        <span class="type">Thread</span>.sleep(forTimeInterval: <span class="number">2</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"🍎"</span>, i, <span class="type">Thread</span>.current)</span><br><span class="line">    &#125;</span><br><span class="line">    group.leave()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">group.enter()</span><br><span class="line"><span class="type">DispatchQueue</span>.global().async() &#123;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">5</span>..&lt;<span class="number">10</span> &#123;</span><br><span class="line">        <span class="type">Thread</span>.sleep(forTimeInterval: <span class="number">2</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"🍊"</span>, i, <span class="type">Thread</span>.current)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    group.leave()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">group.notify(queue: <span class="type">DispatchQueue</span>.main) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"finished"</span>, <span class="type">Thread</span>.current)</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Printe</span>:</span><br><span class="line">🍎 <span class="number">1</span> &lt;<span class="type">NSThread</span>: <span class="number">0x600003614100</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line">🍊 <span class="number">5</span> &lt;<span class="type">NSThread</span>: <span class="number">0x600003618f40</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line">🍎 <span class="number">2</span> &lt;<span class="type">NSThread</span>: <span class="number">0x600003614100</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line">🍊 <span class="number">6</span> &lt;<span class="type">NSThread</span>: <span class="number">0x600003618f40</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line">🍊 <span class="number">7</span> &lt;<span class="type">NSThread</span>: <span class="number">0x600003618f40</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line">🍎 <span class="number">3</span> &lt;<span class="type">NSThread</span>: <span class="number">0x600003614100</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line">🍊 <span class="number">8</span> &lt;<span class="type">NSThread</span>: <span class="number">0x600003618f40</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line">🍎 <span class="number">4</span> &lt;<span class="type">NSThread</span>: <span class="number">0x600003614100</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line">🍊 <span class="number">9</span> &lt;<span class="type">NSThread</span>: <span class="number">0x600003618f40</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line">finished &lt;<span class="type">NSThread</span>: <span class="number">0x600003676f40</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br></pre></td></tr></table></figure>
<p><code>enter</code>把一个任务追加到 group，执行一次，相当于 group 中未执行完毕任务数 +１。<br><code>leave</code>代表将任务离开 group，执行一次，相当于 group 中未执行完毕任务数 -１。<br>当 group 中未执行完毕任务数为 0 的时候，才会使<code>wait</code>解除阻塞，以及执行<code>notify</code>中的任务。<br><code>enter</code>和<code>leave</code>的组合就相当于<code>DispatchQueue.global().async(group: group)</code>。</p>
<h2 id="GCD-的一些常用方法"><a href="#GCD-的一些常用方法" class="headerlink" title="GCD 的一些常用方法"></a>GCD 的一些常用方法</h2><h3 id="延迟执行"><a href="#延迟执行" class="headerlink" title="延迟执行"></a>延迟执行</h3><p>有时我们会需要延迟指定时间后执行某个任务。为此 GCD 提供了延迟方法。<br>我们先来看看 GCD 提供的间隔时间单位：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">DispatchTimeInterval</span> : <span class="title">Equatable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> seconds(<span class="type">Int</span>)</span><br><span class="line">    <span class="comment">// 秒</span></span><br><span class="line">    <span class="keyword">case</span> milliseconds(<span class="type">Int</span>)</span><br><span class="line">    <span class="comment">// 毫秒（千分之一秒）</span></span><br><span class="line">    <span class="keyword">case</span> microseconds(<span class="type">Int</span>)</span><br><span class="line">    <span class="comment">// 微妙（百万分之一秒）</span></span><br><span class="line">    <span class="keyword">case</span> nanoseconds(<span class="type">Int</span>)</span><br><span class="line">    <span class="comment">// 纳秒（十亿分之一秒）</span></span><br><span class="line">    <span class="keyword">case</span> never</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们创建一个延迟时间：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> timeInterval: <span class="type">DispatchTimeInterval</span> = .seconds(<span class="number">3</span>)</span><br><span class="line"><span class="type">DispatchQueue</span>.main.asyncAfter(deadline: .now() + timeInterval) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="type">Date</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行一下，你会发现任务会在延迟 3 秒后执行。当然 deadline 参数上也可以不使用 now()，但是就需要手动指定一个 DispatchTime 类型的值作为参数。这只是一个简单的延迟执行，但大多数情况都够用。</p>
<h3 id="Barrier"><a href="#Barrier" class="headerlink" title="Barrier"></a>Barrier</h3><p>在开发中有时需要任务二要等待任务一执行结束，使用任务一的计算结果执行任务二。这种顺序就像我们做听力回答，必须要听完问题，才能知道如何回答，或是说任务一的结束就是为了任务二的开始，缺少了任务一的结束，任务二无法开始。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> concurrentQueue = <span class="type">DispatchQueue</span>(label: <span class="string">"concurrent"</span>, qos: .userInteractive, attributes: .concurrent)</span><br><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> one = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">concurrentQueue.async() &#123;</span><br><span class="line">    <span class="type">Thread</span>.sleep(forTimeInterval: <span class="number">3</span>)</span><br><span class="line">    sum = one + <span class="number">10</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"sleep"</span>, <span class="type">Thread</span>.current)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">concurrentQueue.async &#123;</span><br><span class="line">    <span class="built_in">print</span>(sum, <span class="type">Thread</span>.current)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">concurrentQueue.async(flags: .barrier) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"barrier"</span>, sum, <span class="type">Thread</span>.current)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">concurrentQueue.async &#123;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..&lt;<span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"🍎"</span>, i, <span class="type">Thread</span>.current)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">concurrentQueue.async &#123;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">5</span>..&lt;<span class="number">10</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"🍊"</span>, i, <span class="type">Thread</span>.current)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Prints</span>:</span><br><span class="line"><span class="number">0</span> &lt;<span class="type">NSThread</span>: <span class="number">0x600001b44e00</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line">sleep &lt;<span class="type">NSThread</span>: <span class="number">0x600001b78200</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line">barrier <span class="number">10</span> &lt;<span class="type">NSThread</span>: <span class="number">0x600001b78200</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line">🍎 <span class="number">1</span> &lt;<span class="type">NSThread</span>: <span class="number">0x600001b78200</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line">🍎 <span class="number">2</span> &lt;<span class="type">NSThread</span>: <span class="number">0x600001b78200</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line">🍎 <span class="number">3</span> &lt;<span class="type">NSThread</span>: <span class="number">0x600001b78200</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line">🍎 <span class="number">4</span> &lt;<span class="type">NSThread</span>: <span class="number">0x600001b78200</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line">🍊 <span class="number">5</span> &lt;<span class="type">NSThread</span>: <span class="number">0x600001b55700</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br><span class="line">🍊 <span class="number">6</span> &lt;<span class="type">NSThread</span>: <span class="number">0x600001b55700</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br><span class="line">🍊 <span class="number">7</span> &lt;<span class="type">NSThread</span>: <span class="number">0x600001b55700</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br><span class="line">🍊 <span class="number">8</span> &lt;<span class="type">NSThread</span>: <span class="number">0x600001b55700</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br><span class="line">🍊 <span class="number">9</span> &lt;<span class="type">NSThread</span>: <span class="number">0x600001b55700</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<p>可以清晰的看到队列使用 barrier 的语法，以及 barrier flag 的异步函数会等待前面添加到并发队列中的任务执行完毕之后，再将指定的任务追加到该异步队列中。然后在 barrier flag 的异步函数追加的任务执行完毕之后，异步队列才恢复正常，接着追加任务到该异步队列并开始执行。</p>
<p>关于 Barrier 详情也可看这里 <a href="https://medium.com/@oyalhi/dispatch-barriers-in-swift-3-6c4a295215d6" target="_blank" rel="noopener">Dispatch Barriers in Swift 3</a>。</p>
<h3 id="concurrentPerform（迭代）"><a href="#concurrentPerform（迭代）" class="headerlink" title="concurrentPerform（迭代）"></a>concurrentPerform（迭代）</h3><p><code>concurrentPerform</code>会按设置的指定次数将任务追加到指定的队列，并等待所有任务全部执行完毕，类似于<code>sync</code>函数。因此推荐在<code>async</code>函数中异步执行<code>concurrentPerform</code>，<code>concurrentPerform</code>可以实现高性能的循环迭代，多线程执行任务。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> array = <span class="type">Array</span>(<span class="number">1</span>...<span class="number">100</span>)</span><br><span class="line"><span class="keyword">var</span> result = [<span class="type">Int</span>]()</span><br><span class="line"><span class="type">DispatchQueue</span>.concurrentPerform(iterations: <span class="number">100</span>) &#123; (index) <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">if</span> array[index] % <span class="number">7</span> == <span class="number">0</span> &#123;</span><br><span class="line">        result.append(array[index])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行这段代码你会发现 crash 了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">malloc: *** error for object: pointer being freed was not allocated</span><br></pre></td></tr></table></figure>
<p>why？因为<code>concurrentPerform</code>是并发执行的，线程 2 访问时可能已经被线程 1 free 了指针。</p>
<p>所以在异步中执行：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> array = <span class="type">Array</span>(<span class="number">1</span>...<span class="number">100</span>)</span><br><span class="line"><span class="keyword">var</span> result = [<span class="type">Int</span>]()</span><br><span class="line"><span class="type">DispatchQueue</span>.global().async &#123;</span><br><span class="line">    <span class="type">DispatchQueue</span>.concurrentPerform(iterations: <span class="number">100</span>) &#123; (index) <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(index)</span><br><span class="line">        <span class="keyword">if</span> array[index] % <span class="number">7</span> == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">                result.append(array[index])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"result"</span>, result)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就会阻塞线程直到任务执行完毕，最后回到主线程查看更新结果。</p>
<h3 id="DispatchSourceTimer"><a href="#DispatchSourceTimer" class="headerlink" title="DispatchSourceTimer"></a>DispatchSourceTimer</h3><p><code>DispatchSourceTimer</code>要比<code>NSTimer</code>更加优雅、高效，它是一种与<code>DispatchQueue</code>结合的定时器。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">DispatchSource</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">timer</span>(<span class="title">interval</span>: <span class="title">Double</span>, <span class="title">queue</span>: <span class="title">DispatchQueue</span>, <span class="title">handler</span>: @<span class="title">escaping</span> () -&gt; <span class="title">Void</span>) -&gt; <span class="title">DispatchSourceTimer</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置执行队列</span></span><br><span class="line">        <span class="keyword">let</span> source = <span class="type">DispatchSource</span>.makeTimerSource(queue: queue)</span><br><span class="line">        <span class="comment">// 设置时间回调处理</span></span><br><span class="line">        source.setEventHandler(handler: handler)</span><br><span class="line">        source.schedule(deadline: .now(), repeating: interval, leeway: .nanoseconds(<span class="number">0</span>))</span><br><span class="line">        source.resume()</span><br><span class="line">        <span class="keyword">return</span> source</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> timer: <span class="type">DispatchSourceTimer</span>!</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">        timer = <span class="type">DispatchSource</span>.timer(interval: <span class="number">2</span>, queue: <span class="type">DispatchQueue</span>.main) &#123;</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            <span class="built_in">print</span>(i)</span><br><span class="line">        &#125;</span><br><span class="line">        timer.activate()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>你会发现我们声明了一个名为<code>timer</code>的成员属性，使用成员属性是有必要的，因为如果在<code>viewDidLoad</code>中定义的，只在该方法中可用。当它退出这个方法时，应用程序将无法使用这个变量，我们也无法激活这个队列，最重要的是，可能会造成运行时崩溃。<br>停止定时器的方法有两种<code>suspend</code>和<code>cancel</code>。</p>
<ul>
<li><code>suspend</code>只是将<code>timer</code>挂起，并没有销毁。</li>
<li><code>cancel</code>是取消并销毁。</li>
</ul>
<blockquote>
<p><strong>By the way</strong><br><code>DispatchSource</code> 简单来说是监听系统底层对象的活动。以后会在我的博客中单独分出一章，其涉及到的东西很多，也偏向底层。虽然开发中基本不会用到，对于经常和底层打交道的开发者来说可能更需这个坑，但这些原理是作为 iOS Developer 成长时应该了解的。所以这里只写了更常用的<code>DispatchSourceTimer</code>。</p>
</blockquote>
<h3 id="Once"><a href="#Once" class="headerlink" title="Once"></a>Once</h3><p>Dispath once 已经被废弃了，如果你想尝试自己扩展推荐如下资料：<br><a href="https://www.jianshu.com/p/640b64faea9a" target="_blank" rel="noopener">[译]Swift 3 中实现Dispatch once扩展</a><br><a href="https://stackoverflow.com/questions/37886994/dispatch-once-after-the-swift-3-gcd-api-changes" target="_blank" rel="noopener">dispatch_once after the Swift 3 GCD API changes</a></p>
<h2 id="更多资料："><a href="#更多资料：" class="headerlink" title="更多资料："></a>更多资料：</h2><p>更多关于 GCD 的资料请参考这里<br><a href="https://github.com/apple/swift-corelibs-libdispatch" target="_blank" rel="noopener">官方 GCD Swift 源码</a><br><a href="https://www.raywenderlich.com/5370-grand-central-dispatch-tutorial-for-swift-4-part-1-2" target="_blank" rel="noopener">Grand Cnntaal Dispatch Tutorial for Swift 4</a><br><a href="https://www.appcoda.com/grand-central-dispatch" target="_blank" rel="noopener">Grand Central Dispatch (GCD) and Dispatch Queues in Swift 3</a><br><a href="http://fulmanski.pl/tutorials/apple/macos/concurrency-asynchronicity-and-background-processing/#gcd_sources_examples" target="_blank" rel="noopener">THE GRAND CENTRAL DISPATCH</a><br><a href="https://bujige.net/blog/iOS-Complete-learning-GCD.html" target="_blank" rel="noopener">iOS 多线程：『GCD』详尽总结</a><br><a href="https://github.com/ming1016/study/wiki/细说GCD（Grand-Central-Dispatch）如何用" target="_blank" rel="noopener">细说GCD（Grand Central Dispatch）如何用</a><br><a href="https://bestswifter.com/deep-gcd/" target="_blank" rel="noopener">深入了解GCD</a></p>

      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/04/21/偶然发现的POST请求参数问题/" rel="next" title="偶然发现的POST请求参数问题">
                <i class="fa fa-chevron-left"></i> 偶然发现的POST请求参数问题
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">MorningStar</p>
              <p class="site-description motion-element" itemprop="description">Talk is cheap, show me the code</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">5</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              

              
            </nav>
          

          

          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                友情推荐
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.boxueio.com/" title="泊学－全栈开发者的修炼攻略" target="_blank">泊学－全栈开发者的修炼攻略</a>
                  </li>
                
              </ul>
            </div>
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#CGD-的简述"><span class="nav-number">1.</span> <span class="nav-text">CGD 的简述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GCD-的核心"><span class="nav-number">2.</span> <span class="nav-text">GCD 的核心</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#任务及其执行方式"><span class="nav-number">2.1.</span> <span class="nav-text">任务及其执行方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#队列"><span class="nav-number">2.2.</span> <span class="nav-text">队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#队列以及执行方式的组合使用"><span class="nav-number">2.3.</span> <span class="nav-text">队列以及执行方式的组合使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Dispatch-Queue"><span class="nav-number">2.3.1.</span> <span class="nav-text">Dispatch Queue</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#串行队列（Serial-Dispatch-Queue）"><span class="nav-number">2.3.2.</span> <span class="nav-text">串行队列（Serial Dispatch Queue）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#串行队列同步执行"><span class="nav-number">2.3.2.1.</span> <span class="nav-text">串行队列同步执行</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#串行队列异步执行"><span class="nav-number">2.3.2.2.</span> <span class="nav-text">串行队列异步执行</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DispatchQoS"><span class="nav-number">2.3.3.</span> <span class="nav-text">DispatchQoS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#并行队列（Concurrent-Dispatch-Queue）"><span class="nav-number">2.3.4.</span> <span class="nav-text">并行队列（Concurrent Dispatch Queue）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#并行队列异步执行"><span class="nav-number">2.3.4.1.</span> <span class="nav-text">并行队列异步执行</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#并行队列同步执行"><span class="nav-number">2.3.4.2.</span> <span class="nav-text">并行队列同步执行</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#系统提供的现有队列"><span class="nav-number">2.3.5.</span> <span class="nav-text">系统提供的现有队列</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#主队列"><span class="nav-number">2.3.5.1.</span> <span class="nav-text">主队列</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#主队列同步执行与死锁"><span class="nav-number">2.3.5.1.1.</span> <span class="nav-text">主队列同步执行与死锁</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#主队列异步执行"><span class="nav-number">2.3.5.1.2.</span> <span class="nav-text">主队列异步执行</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#DispatchGroup"><span class="nav-number">2.3.5.2.</span> <span class="nav-text">DispatchGroup</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#DispatchGroup-notify"><span class="nav-number">2.3.5.2.1.</span> <span class="nav-text">DispatchGroup( ).notify</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#DispatchGroup-wait"><span class="nav-number">2.3.5.2.2.</span> <span class="nav-text">DispatchGroup( ).wait</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#DispatchGroup-enter、DispatchGroup-leave"><span class="nav-number">2.3.5.2.3.</span> <span class="nav-text">DispatchGroup().enter、DispatchGroup().leave</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GCD-的一些常用方法"><span class="nav-number">3.</span> <span class="nav-text">GCD 的一些常用方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#延迟执行"><span class="nav-number">3.1.</span> <span class="nav-text">延迟执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Barrier"><span class="nav-number">3.2.</span> <span class="nav-text">Barrier</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#concurrentPerform（迭代）"><span class="nav-number">3.3.</span> <span class="nav-text">concurrentPerform（迭代）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DispatchSourceTimer"><span class="nav-number">3.4.</span> <span class="nav-text">DispatchSourceTimer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Once"><span class="nav-number">3.5.</span> <span class="nav-text">Once</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#更多资料："><span class="nav-number">4.</span> <span class="nav-text">更多资料：</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate"> 
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">MorningStar</span>

  

  
</div>




  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Muse</a> v6.0.6</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  













  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.6"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.6"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.0.6"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.0.6"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.6"></script>



  



	





  





  










  





  

  

  

  

  
  

  

  

  

  

</body>
</html>
